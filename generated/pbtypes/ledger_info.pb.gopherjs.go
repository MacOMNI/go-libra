// +build js
// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: ledger_info.proto

package pbtypes

import jspb "github.com/johanbrandhorst/protobuf/jspb"

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

// / Even though we don't always need all hashes, we pass them in and return them
// / always so that we keep them in sync on the client and don't make the client
// / worry about which one(s) to pass in which cases
// /
// / This structure serves a dual purpose.
// /
// / First, if this structure is signed by 2f+1 validators it signifies the state
// / of the ledger at version `version` -- it contains the transaction
// / accumulator at that version which commits to all historical transactions.
// / This structure may be expanded to include other information that is derived
// / from that accumulator (e.g. the current time according to the time contract)
// / to reduce the number of proofs a client must get.
// /
// / Second, the structure contains a `consensus_data_hash` value. This is the
// / hash of an internal data structure that represents a block that is voted on
// / by consensus.
// /
// / Combining these two concepts when the consensus algorithm votes on a block B
// / it votes for a LedgerInfo with the `version` being the latest version that
// / will be committed if B gets 2f+1 votes. It sets `consensus_data_hash` to
// / represent B so that if those 2f+1 votes are gathered, the block is valid to
// / commit
type LedgerInfo struct {
	// Current latest version of the system
	Version uint64
	// Root hash of transaction accumulator at this version
	TransactionAccumulatorHash []byte
	// Hash of consensus-specific data that is opaque to all parts of the system
	// other than consensus.  This is needed to verify signatures because
	// consensus signing includes this hash
	ConsensusDataHash []byte
	// The block id of the last committed block corresponding to this ledger info.
	// This field is not particularly interesting to the clients, but can be used
	// by the validators for synchronization.
	ConsensusBlockId []byte
	// Epoch number corresponds to the set of validators that are active for this
	// ledger info. The main motivation for keeping the epoch number in the
	// LedgerInfo is to ensure that the client has enough information to verify
	// that the signatures for this info are coming from the validators that
	// indeed form a quorum. Without epoch number a potential attack could reuse
	// the signatures from the validators in one epoch in order to sign the wrong
	// info belonging to another epoch, in which these validators do not form a
	// quorum. The very first epoch number is 0.
	Epoch uint64
	// Consensus protocol operates in rounds: the number corresponds to the
	// proposal round of a given commit. Not relevant to the clients, but can be
	// used by the validators for synchronization.
	Round uint64
	// Timestamp that represents the microseconds since the epoch (unix time) that
	// is generated by the proposer of the block.  This is strictly increasing
	// with every block. If a client reads a timestamp > the one they specified
	// for transaction expiration time, they can be certain that their transaction
	// will never be included in a block in the future (assuming that their
	// transaction has not yet been included)
	TimestampUsecs uint64
	// An optional field with the validator set for the next epoch in case it's
	// the last ledger info in the current epoch.
	NextValidatorSet *ValidatorSet
}

// GetVersion gets the Version of the LedgerInfo.
func (m *LedgerInfo) GetVersion() (x uint64) {
	if m == nil {
		return x
	}
	return m.Version
}

// GetTransactionAccumulatorHash gets the TransactionAccumulatorHash of the LedgerInfo.
func (m *LedgerInfo) GetTransactionAccumulatorHash() (x []byte) {
	if m == nil {
		return x
	}
	return m.TransactionAccumulatorHash
}

// GetConsensusDataHash gets the ConsensusDataHash of the LedgerInfo.
func (m *LedgerInfo) GetConsensusDataHash() (x []byte) {
	if m == nil {
		return x
	}
	return m.ConsensusDataHash
}

// GetConsensusBlockId gets the ConsensusBlockId of the LedgerInfo.
func (m *LedgerInfo) GetConsensusBlockId() (x []byte) {
	if m == nil {
		return x
	}
	return m.ConsensusBlockId
}

// GetEpoch gets the Epoch of the LedgerInfo.
func (m *LedgerInfo) GetEpoch() (x uint64) {
	if m == nil {
		return x
	}
	return m.Epoch
}

// GetRound gets the Round of the LedgerInfo.
func (m *LedgerInfo) GetRound() (x uint64) {
	if m == nil {
		return x
	}
	return m.Round
}

// GetTimestampUsecs gets the TimestampUsecs of the LedgerInfo.
func (m *LedgerInfo) GetTimestampUsecs() (x uint64) {
	if m == nil {
		return x
	}
	return m.TimestampUsecs
}

// GetNextValidatorSet gets the NextValidatorSet of the LedgerInfo.
func (m *LedgerInfo) GetNextValidatorSet() (x *ValidatorSet) {
	if m == nil {
		return x
	}
	return m.NextValidatorSet
}

// MarshalToWriter marshals LedgerInfo to the provided writer.
func (m *LedgerInfo) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Version != 0 {
		writer.WriteUint64(1, m.Version)
	}

	if len(m.TransactionAccumulatorHash) > 0 {
		writer.WriteBytes(2, m.TransactionAccumulatorHash)
	}

	if len(m.ConsensusDataHash) > 0 {
		writer.WriteBytes(3, m.ConsensusDataHash)
	}

	if len(m.ConsensusBlockId) > 0 {
		writer.WriteBytes(4, m.ConsensusBlockId)
	}

	if m.Epoch != 0 {
		writer.WriteUint64(5, m.Epoch)
	}

	if m.Round != 0 {
		writer.WriteUint64(6, m.Round)
	}

	if m.TimestampUsecs != 0 {
		writer.WriteUint64(7, m.TimestampUsecs)
	}

	if m.NextValidatorSet != nil {
		writer.WriteMessage(8, func() {
			m.NextValidatorSet.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals LedgerInfo to a slice of bytes.
func (m *LedgerInfo) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a LedgerInfo from the provided reader.
func (m *LedgerInfo) UnmarshalFromReader(reader jspb.Reader) *LedgerInfo {
	for reader.Next() {
		if m == nil {
			m = &LedgerInfo{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Version = reader.ReadUint64()
		case 2:
			m.TransactionAccumulatorHash = reader.ReadBytes()
		case 3:
			m.ConsensusDataHash = reader.ReadBytes()
		case 4:
			m.ConsensusBlockId = reader.ReadBytes()
		case 5:
			m.Epoch = reader.ReadUint64()
		case 6:
			m.Round = reader.ReadUint64()
		case 7:
			m.TimestampUsecs = reader.ReadUint64()
		case 8:
			reader.ReadMessage(func() {
				m.NextValidatorSet = m.NextValidatorSet.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a LedgerInfo from a slice of bytes.
func (m *LedgerInfo) Unmarshal(rawBytes []byte) (*LedgerInfo, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// / The validator node returns this structure which includes signatures
// / from each validator to confirm the state.  The client needs to only pass
// / back the LedgerInfo element since the validator node doesn't need to know
// / the signatures again when the client performs a query, those are only there
// / for the client to be able to verify the state
type LedgerInfoWithSignatures struct {
	Bytes []byte
}

// GetBytes gets the Bytes of the LedgerInfoWithSignatures.
func (m *LedgerInfoWithSignatures) GetBytes() (x []byte) {
	if m == nil {
		return x
	}
	return m.Bytes
}

// MarshalToWriter marshals LedgerInfoWithSignatures to the provided writer.
func (m *LedgerInfoWithSignatures) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Bytes) > 0 {
		writer.WriteBytes(1, m.Bytes)
	}

	return
}

// Marshal marshals LedgerInfoWithSignatures to a slice of bytes.
func (m *LedgerInfoWithSignatures) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a LedgerInfoWithSignatures from the provided reader.
func (m *LedgerInfoWithSignatures) UnmarshalFromReader(reader jspb.Reader) *LedgerInfoWithSignatures {
	for reader.Next() {
		if m == nil {
			m = &LedgerInfoWithSignatures{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Bytes = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a LedgerInfoWithSignatures from a slice of bytes.
func (m *LedgerInfoWithSignatures) Unmarshal(rawBytes []byte) (*LedgerInfoWithSignatures, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ValidatorSignature struct {
	// The account address of the validator, which can be used for retrieving its
	// public key during the given epoch.
	ValidatorId []byte
	Signature   []byte
}

// GetValidatorId gets the ValidatorId of the ValidatorSignature.
func (m *ValidatorSignature) GetValidatorId() (x []byte) {
	if m == nil {
		return x
	}
	return m.ValidatorId
}

// GetSignature gets the Signature of the ValidatorSignature.
func (m *ValidatorSignature) GetSignature() (x []byte) {
	if m == nil {
		return x
	}
	return m.Signature
}

// MarshalToWriter marshals ValidatorSignature to the provided writer.
func (m *ValidatorSignature) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.ValidatorId) > 0 {
		writer.WriteBytes(1, m.ValidatorId)
	}

	if len(m.Signature) > 0 {
		writer.WriteBytes(2, m.Signature)
	}

	return
}

// Marshal marshals ValidatorSignature to a slice of bytes.
func (m *ValidatorSignature) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ValidatorSignature from the provided reader.
func (m *ValidatorSignature) UnmarshalFromReader(reader jspb.Reader) *ValidatorSignature {
	for reader.Next() {
		if m == nil {
			m = &ValidatorSignature{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.ValidatorId = reader.ReadBytes()
		case 2:
			m.Signature = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ValidatorSignature from a slice of bytes.
func (m *ValidatorSignature) Unmarshal(rawBytes []byte) (*ValidatorSignature, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}
