// +build js
// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: validator_info.proto

package pbtypes

import jspb "github.com/johanbrandhorst/protobuf/jspb"

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

// Protobuf definition for the Rust struct ValidatorInfo
type ValidatorInfo struct {
	// Validator account address
	AccountAddress []byte
	// Consensus public key
	ConsensusPublicKey []byte
	// Validator voting power for consensus
	ConsensusVotingPower uint64
	// Network signing publick key
	NetworkSigningPublicKey []byte
	// / Network identity publick key
	NetworkIdentityPublicKey []byte
}

// GetAccountAddress gets the AccountAddress of the ValidatorInfo.
func (m *ValidatorInfo) GetAccountAddress() (x []byte) {
	if m == nil {
		return x
	}
	return m.AccountAddress
}

// GetConsensusPublicKey gets the ConsensusPublicKey of the ValidatorInfo.
func (m *ValidatorInfo) GetConsensusPublicKey() (x []byte) {
	if m == nil {
		return x
	}
	return m.ConsensusPublicKey
}

// GetConsensusVotingPower gets the ConsensusVotingPower of the ValidatorInfo.
func (m *ValidatorInfo) GetConsensusVotingPower() (x uint64) {
	if m == nil {
		return x
	}
	return m.ConsensusVotingPower
}

// GetNetworkSigningPublicKey gets the NetworkSigningPublicKey of the ValidatorInfo.
func (m *ValidatorInfo) GetNetworkSigningPublicKey() (x []byte) {
	if m == nil {
		return x
	}
	return m.NetworkSigningPublicKey
}

// GetNetworkIdentityPublicKey gets the NetworkIdentityPublicKey of the ValidatorInfo.
func (m *ValidatorInfo) GetNetworkIdentityPublicKey() (x []byte) {
	if m == nil {
		return x
	}
	return m.NetworkIdentityPublicKey
}

// MarshalToWriter marshals ValidatorInfo to the provided writer.
func (m *ValidatorInfo) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.AccountAddress) > 0 {
		writer.WriteBytes(1, m.AccountAddress)
	}

	if len(m.ConsensusPublicKey) > 0 {
		writer.WriteBytes(2, m.ConsensusPublicKey)
	}

	if m.ConsensusVotingPower != 0 {
		writer.WriteUint64(3, m.ConsensusVotingPower)
	}

	if len(m.NetworkSigningPublicKey) > 0 {
		writer.WriteBytes(4, m.NetworkSigningPublicKey)
	}

	if len(m.NetworkIdentityPublicKey) > 0 {
		writer.WriteBytes(5, m.NetworkIdentityPublicKey)
	}

	return
}

// Marshal marshals ValidatorInfo to a slice of bytes.
func (m *ValidatorInfo) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ValidatorInfo from the provided reader.
func (m *ValidatorInfo) UnmarshalFromReader(reader jspb.Reader) *ValidatorInfo {
	for reader.Next() {
		if m == nil {
			m = &ValidatorInfo{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.AccountAddress = reader.ReadBytes()
		case 2:
			m.ConsensusPublicKey = reader.ReadBytes()
		case 3:
			m.ConsensusVotingPower = reader.ReadUint64()
		case 4:
			m.NetworkSigningPublicKey = reader.ReadBytes()
		case 5:
			m.NetworkIdentityPublicKey = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ValidatorInfo from a slice of bytes.
func (m *ValidatorInfo) Unmarshal(rawBytes []byte) (*ValidatorInfo, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}
