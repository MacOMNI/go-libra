// +build js
// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: access_path.proto

/*
	Package pbtypes is a generated protocol buffer package.

	It is generated from these files:
		access_path.proto
		account_state_blob.proto
		events.proto
		get_with_proof.proto
		language_storage.proto
		ledger_info.proto
		proof.proto
		transaction_info.proto
		transaction.proto
		validator_change.proto
		validator_public_keys.proto
		validator_set.proto
		vm_errors.proto

	It has these top-level messages:
		AccessPath
		AccountStateBlob
		AccountStateWithProof
		Event
		EventWithProof
		EventsList
		EventsForVersions
		UpdateToLatestLedgerRequest
		RequestItem
		UpdateToLatestLedgerResponse
		ResponseItem
		GetAccountStateRequest
		GetAccountStateResponse
		GetAccountTransactionBySequenceNumberRequest
		GetAccountTransactionBySequenceNumberResponse
		GetEventsByEventAccessPathRequest
		GetEventsByEventAccessPathResponse
		GetTransactionsRequest
		GetTransactionsResponse
		ModuleId
		LedgerInfo
		LedgerInfoWithSignatures
		ValidatorSignature
		AccumulatorProof
		SparseMerkleProof
		AccumulatorConsistencyProof
		AccumulatorRangeProof
		SparseMerkleRangeProof
		TransactionProof
		AccountStateProof
		EventProof
		TransactionListProof
		TransactionInfo
		TransactionArgument
		SignedTransaction
		Transaction
		TransactionWithProof
		SignedTransactionsBlock
		AccountState
		TransactionToCommit
		TransactionListWithProof
		ValidatorChangeProof
		ValidatorPublicKeys
		ValidatorSet
		VMStatus
*/
package pbtypes

import jspb "github.com/johanbrandhorst/protobuf/jspb"

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

type AccessPath struct {
	Address []byte
	Path    []byte
}

// GetAddress gets the Address of the AccessPath.
func (m *AccessPath) GetAddress() (x []byte) {
	if m == nil {
		return x
	}
	return m.Address
}

// GetPath gets the Path of the AccessPath.
func (m *AccessPath) GetPath() (x []byte) {
	if m == nil {
		return x
	}
	return m.Path
}

// MarshalToWriter marshals AccessPath to the provided writer.
func (m *AccessPath) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Address) > 0 {
		writer.WriteBytes(1, m.Address)
	}

	if len(m.Path) > 0 {
		writer.WriteBytes(2, m.Path)
	}

	return
}

// Marshal marshals AccessPath to a slice of bytes.
func (m *AccessPath) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a AccessPath from the provided reader.
func (m *AccessPath) UnmarshalFromReader(reader jspb.Reader) *AccessPath {
	for reader.Next() {
		if m == nil {
			m = &AccessPath{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Address = reader.ReadBytes()
		case 2:
			m.Path = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a AccessPath from a slice of bytes.
func (m *AccessPath) Unmarshal(rawBytes []byte) (*AccessPath, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}
