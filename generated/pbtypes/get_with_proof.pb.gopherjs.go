// +build js
// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: get_with_proof.proto

package pbtypes

import jspb "github.com/johanbrandhorst/protobuf/jspb"

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

// This API is used to update the client to the latest ledger version and
// optionally also request 1..n other pieces of data.  This allows for batch
// queries.  All queries return proofs that a client should check to validate
// the data.
//
// Note that if a client only wishes to update to the latest LedgerInfo and
// receive the proof that this latest ledger extends the client_known_version
// ledger the client had, they can simply set the requested_items to an empty
// list.
type UpdateToLatestLedgerRequest struct {
	// This is the version the client already trusts. Usually the client should
	// set this to the version it obtained the last time it synced with the
	// chain. If this is the first time ever the client sends a request, it must
	// use the waypoint hard-coded in its software.
	ClientKnownVersion uint64
	// The items for which we are requesting data in this API call.
	RequestedItems []*RequestItem
}

// GetClientKnownVersion gets the ClientKnownVersion of the UpdateToLatestLedgerRequest.
func (m *UpdateToLatestLedgerRequest) GetClientKnownVersion() (x uint64) {
	if m == nil {
		return x
	}
	return m.ClientKnownVersion
}

// GetRequestedItems gets the RequestedItems of the UpdateToLatestLedgerRequest.
func (m *UpdateToLatestLedgerRequest) GetRequestedItems() (x []*RequestItem) {
	if m == nil {
		return x
	}
	return m.RequestedItems
}

// MarshalToWriter marshals UpdateToLatestLedgerRequest to the provided writer.
func (m *UpdateToLatestLedgerRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.ClientKnownVersion != 0 {
		writer.WriteUint64(1, m.ClientKnownVersion)
	}

	for _, msg := range m.RequestedItems {
		writer.WriteMessage(2, func() {
			msg.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals UpdateToLatestLedgerRequest to a slice of bytes.
func (m *UpdateToLatestLedgerRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a UpdateToLatestLedgerRequest from the provided reader.
func (m *UpdateToLatestLedgerRequest) UnmarshalFromReader(reader jspb.Reader) *UpdateToLatestLedgerRequest {
	for reader.Next() {
		if m == nil {
			m = &UpdateToLatestLedgerRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.ClientKnownVersion = reader.ReadUint64()
		case 2:
			reader.ReadMessage(func() {
				m.RequestedItems = append(m.RequestedItems, new(RequestItem).UnmarshalFromReader(reader))
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a UpdateToLatestLedgerRequest from a slice of bytes.
func (m *UpdateToLatestLedgerRequest) Unmarshal(rawBytes []byte) (*UpdateToLatestLedgerRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type RequestItem struct {
	// Types that are valid to be assigned to RequestedItems:
	//	*RequestItem_GetAccountStateRequest
	//	*RequestItem_GetAccountTransactionBySequenceNumberRequest
	//	*RequestItem_GetEventsByEventAccessPathRequest
	//	*RequestItem_GetTransactionsRequest
	RequestedItems isRequestItem_RequestedItems
}

// isRequestItem_RequestedItems is used to distinguish types assignable to RequestedItems
type isRequestItem_RequestedItems interface{ isRequestItem_RequestedItems() }

// RequestItem_GetAccountStateRequest is assignable to RequestedItems
type RequestItem_GetAccountStateRequest struct {
	GetAccountStateRequest *GetAccountStateRequest
}

// RequestItem_GetAccountTransactionBySequenceNumberRequest is assignable to RequestedItems
type RequestItem_GetAccountTransactionBySequenceNumberRequest struct {
	GetAccountTransactionBySequenceNumberRequest *GetAccountTransactionBySequenceNumberRequest
}

// RequestItem_GetEventsByEventAccessPathRequest is assignable to RequestedItems
type RequestItem_GetEventsByEventAccessPathRequest struct {
	GetEventsByEventAccessPathRequest *GetEventsByEventAccessPathRequest
}

// RequestItem_GetTransactionsRequest is assignable to RequestedItems
type RequestItem_GetTransactionsRequest struct {
	GetTransactionsRequest *GetTransactionsRequest
}

func (*RequestItem_GetAccountStateRequest) isRequestItem_RequestedItems()                       {}
func (*RequestItem_GetAccountTransactionBySequenceNumberRequest) isRequestItem_RequestedItems() {}
func (*RequestItem_GetEventsByEventAccessPathRequest) isRequestItem_RequestedItems()            {}
func (*RequestItem_GetTransactionsRequest) isRequestItem_RequestedItems()                       {}

// GetRequestedItems gets the RequestedItems of the RequestItem.
func (m *RequestItem) GetRequestedItems() (x isRequestItem_RequestedItems) {
	if m == nil {
		return x
	}
	return m.RequestedItems
}

// GetGetAccountStateRequest gets the GetAccountStateRequest of the RequestItem.
func (m *RequestItem) GetGetAccountStateRequest() (x *GetAccountStateRequest) {
	if v, ok := m.GetRequestedItems().(*RequestItem_GetAccountStateRequest); ok {
		return v.GetAccountStateRequest
	}
	return x
}

// GetGetAccountTransactionBySequenceNumberRequest gets the GetAccountTransactionBySequenceNumberRequest of the RequestItem.
func (m *RequestItem) GetGetAccountTransactionBySequenceNumberRequest() (x *GetAccountTransactionBySequenceNumberRequest) {
	if v, ok := m.GetRequestedItems().(*RequestItem_GetAccountTransactionBySequenceNumberRequest); ok {
		return v.GetAccountTransactionBySequenceNumberRequest
	}
	return x
}

// GetGetEventsByEventAccessPathRequest gets the GetEventsByEventAccessPathRequest of the RequestItem.
func (m *RequestItem) GetGetEventsByEventAccessPathRequest() (x *GetEventsByEventAccessPathRequest) {
	if v, ok := m.GetRequestedItems().(*RequestItem_GetEventsByEventAccessPathRequest); ok {
		return v.GetEventsByEventAccessPathRequest
	}
	return x
}

// GetGetTransactionsRequest gets the GetTransactionsRequest of the RequestItem.
func (m *RequestItem) GetGetTransactionsRequest() (x *GetTransactionsRequest) {
	if v, ok := m.GetRequestedItems().(*RequestItem_GetTransactionsRequest); ok {
		return v.GetTransactionsRequest
	}
	return x
}

// MarshalToWriter marshals RequestItem to the provided writer.
func (m *RequestItem) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	switch t := m.RequestedItems.(type) {
	case *RequestItem_GetAccountStateRequest:
		if t.GetAccountStateRequest != nil {
			writer.WriteMessage(1, func() {
				t.GetAccountStateRequest.MarshalToWriter(writer)
			})
		}
	case *RequestItem_GetAccountTransactionBySequenceNumberRequest:
		if t.GetAccountTransactionBySequenceNumberRequest != nil {
			writer.WriteMessage(2, func() {
				t.GetAccountTransactionBySequenceNumberRequest.MarshalToWriter(writer)
			})
		}
	case *RequestItem_GetEventsByEventAccessPathRequest:
		if t.GetEventsByEventAccessPathRequest != nil {
			writer.WriteMessage(3, func() {
				t.GetEventsByEventAccessPathRequest.MarshalToWriter(writer)
			})
		}
	case *RequestItem_GetTransactionsRequest:
		if t.GetTransactionsRequest != nil {
			writer.WriteMessage(4, func() {
				t.GetTransactionsRequest.MarshalToWriter(writer)
			})
		}
	}

	return
}

// Marshal marshals RequestItem to a slice of bytes.
func (m *RequestItem) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a RequestItem from the provided reader.
func (m *RequestItem) UnmarshalFromReader(reader jspb.Reader) *RequestItem {
	for reader.Next() {
		if m == nil {
			m = &RequestItem{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.RequestedItems = &RequestItem_GetAccountStateRequest{
					GetAccountStateRequest: new(GetAccountStateRequest).UnmarshalFromReader(reader),
				}
			})
		case 2:
			reader.ReadMessage(func() {
				m.RequestedItems = &RequestItem_GetAccountTransactionBySequenceNumberRequest{
					GetAccountTransactionBySequenceNumberRequest: new(GetAccountTransactionBySequenceNumberRequest).UnmarshalFromReader(reader),
				}
			})
		case 3:
			reader.ReadMessage(func() {
				m.RequestedItems = &RequestItem_GetEventsByEventAccessPathRequest{
					GetEventsByEventAccessPathRequest: new(GetEventsByEventAccessPathRequest).UnmarshalFromReader(reader),
				}
			})
		case 4:
			reader.ReadMessage(func() {
				m.RequestedItems = &RequestItem_GetTransactionsRequest{
					GetTransactionsRequest: new(GetTransactionsRequest).UnmarshalFromReader(reader),
				}
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a RequestItem from a slice of bytes.
func (m *RequestItem) Unmarshal(rawBytes []byte) (*RequestItem, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Response from getting latest ledger
type UpdateToLatestLedgerResponse struct {
	// Responses to the queries posed by the requests. The proofs generated will
	// be relative to the version of the latest ledger provided below.
	ResponseItems []*ResponseItem
	// The latest ledger info this node has. It will come with at least 2f+1
	// validator signatures as well as a proof that shows the latest ledger
	// extends the old ledger the client had.
	LedgerInfoWithSigs *LedgerInfoWithSignatures
	// A proof for Validator changes from what the client last knew. This is
	// used to inform the client of validator changes from the client's last
	// known version until the current version.
	ValidatorChangeProof *ValidatorChangeProof
	// A proof that shows the latest ledger accumulator is consistent with the
	// old accumulator at "client_known_version".
	LedgerConsistencyProof *AccumulatorConsistencyProof
}

// GetResponseItems gets the ResponseItems of the UpdateToLatestLedgerResponse.
func (m *UpdateToLatestLedgerResponse) GetResponseItems() (x []*ResponseItem) {
	if m == nil {
		return x
	}
	return m.ResponseItems
}

// GetLedgerInfoWithSigs gets the LedgerInfoWithSigs of the UpdateToLatestLedgerResponse.
func (m *UpdateToLatestLedgerResponse) GetLedgerInfoWithSigs() (x *LedgerInfoWithSignatures) {
	if m == nil {
		return x
	}
	return m.LedgerInfoWithSigs
}

// GetValidatorChangeProof gets the ValidatorChangeProof of the UpdateToLatestLedgerResponse.
func (m *UpdateToLatestLedgerResponse) GetValidatorChangeProof() (x *ValidatorChangeProof) {
	if m == nil {
		return x
	}
	return m.ValidatorChangeProof
}

// GetLedgerConsistencyProof gets the LedgerConsistencyProof of the UpdateToLatestLedgerResponse.
func (m *UpdateToLatestLedgerResponse) GetLedgerConsistencyProof() (x *AccumulatorConsistencyProof) {
	if m == nil {
		return x
	}
	return m.LedgerConsistencyProof
}

// MarshalToWriter marshals UpdateToLatestLedgerResponse to the provided writer.
func (m *UpdateToLatestLedgerResponse) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	for _, msg := range m.ResponseItems {
		writer.WriteMessage(1, func() {
			msg.MarshalToWriter(writer)
		})
	}

	if m.LedgerInfoWithSigs != nil {
		writer.WriteMessage(2, func() {
			m.LedgerInfoWithSigs.MarshalToWriter(writer)
		})
	}

	if m.ValidatorChangeProof != nil {
		writer.WriteMessage(3, func() {
			m.ValidatorChangeProof.MarshalToWriter(writer)
		})
	}

	if m.LedgerConsistencyProof != nil {
		writer.WriteMessage(4, func() {
			m.LedgerConsistencyProof.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals UpdateToLatestLedgerResponse to a slice of bytes.
func (m *UpdateToLatestLedgerResponse) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a UpdateToLatestLedgerResponse from the provided reader.
func (m *UpdateToLatestLedgerResponse) UnmarshalFromReader(reader jspb.Reader) *UpdateToLatestLedgerResponse {
	for reader.Next() {
		if m == nil {
			m = &UpdateToLatestLedgerResponse{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.ResponseItems = append(m.ResponseItems, new(ResponseItem).UnmarshalFromReader(reader))
			})
		case 2:
			reader.ReadMessage(func() {
				m.LedgerInfoWithSigs = m.LedgerInfoWithSigs.UnmarshalFromReader(reader)
			})
		case 3:
			reader.ReadMessage(func() {
				m.ValidatorChangeProof = m.ValidatorChangeProof.UnmarshalFromReader(reader)
			})
		case 4:
			reader.ReadMessage(func() {
				m.LedgerConsistencyProof = m.LedgerConsistencyProof.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a UpdateToLatestLedgerResponse from a slice of bytes.
func (m *UpdateToLatestLedgerResponse) Unmarshal(rawBytes []byte) (*UpdateToLatestLedgerResponse, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Individual response items to the queries posed by the requests
type ResponseItem struct {
	// Types that are valid to be assigned to ResponseItems:
	//	*ResponseItem_GetAccountStateResponse
	//	*ResponseItem_GetAccountTransactionBySequenceNumberResponse
	//	*ResponseItem_GetEventsByEventAccessPathResponse
	//	*ResponseItem_GetTransactionsResponse
	ResponseItems isResponseItem_ResponseItems
}

// isResponseItem_ResponseItems is used to distinguish types assignable to ResponseItems
type isResponseItem_ResponseItems interface{ isResponseItem_ResponseItems() }

// ResponseItem_GetAccountStateResponse is assignable to ResponseItems
type ResponseItem_GetAccountStateResponse struct {
	GetAccountStateResponse *GetAccountStateResponse
}

// ResponseItem_GetAccountTransactionBySequenceNumberResponse is assignable to ResponseItems
type ResponseItem_GetAccountTransactionBySequenceNumberResponse struct {
	GetAccountTransactionBySequenceNumberResponse *GetAccountTransactionBySequenceNumberResponse
}

// ResponseItem_GetEventsByEventAccessPathResponse is assignable to ResponseItems
type ResponseItem_GetEventsByEventAccessPathResponse struct {
	GetEventsByEventAccessPathResponse *GetEventsByEventAccessPathResponse
}

// ResponseItem_GetTransactionsResponse is assignable to ResponseItems
type ResponseItem_GetTransactionsResponse struct {
	GetTransactionsResponse *GetTransactionsResponse
}

func (*ResponseItem_GetAccountStateResponse) isResponseItem_ResponseItems()                       {}
func (*ResponseItem_GetAccountTransactionBySequenceNumberResponse) isResponseItem_ResponseItems() {}
func (*ResponseItem_GetEventsByEventAccessPathResponse) isResponseItem_ResponseItems()            {}
func (*ResponseItem_GetTransactionsResponse) isResponseItem_ResponseItems()                       {}

// GetResponseItems gets the ResponseItems of the ResponseItem.
func (m *ResponseItem) GetResponseItems() (x isResponseItem_ResponseItems) {
	if m == nil {
		return x
	}
	return m.ResponseItems
}

// GetGetAccountStateResponse gets the GetAccountStateResponse of the ResponseItem.
func (m *ResponseItem) GetGetAccountStateResponse() (x *GetAccountStateResponse) {
	if v, ok := m.GetResponseItems().(*ResponseItem_GetAccountStateResponse); ok {
		return v.GetAccountStateResponse
	}
	return x
}

// GetGetAccountTransactionBySequenceNumberResponse gets the GetAccountTransactionBySequenceNumberResponse of the ResponseItem.
func (m *ResponseItem) GetGetAccountTransactionBySequenceNumberResponse() (x *GetAccountTransactionBySequenceNumberResponse) {
	if v, ok := m.GetResponseItems().(*ResponseItem_GetAccountTransactionBySequenceNumberResponse); ok {
		return v.GetAccountTransactionBySequenceNumberResponse
	}
	return x
}

// GetGetEventsByEventAccessPathResponse gets the GetEventsByEventAccessPathResponse of the ResponseItem.
func (m *ResponseItem) GetGetEventsByEventAccessPathResponse() (x *GetEventsByEventAccessPathResponse) {
	if v, ok := m.GetResponseItems().(*ResponseItem_GetEventsByEventAccessPathResponse); ok {
		return v.GetEventsByEventAccessPathResponse
	}
	return x
}

// GetGetTransactionsResponse gets the GetTransactionsResponse of the ResponseItem.
func (m *ResponseItem) GetGetTransactionsResponse() (x *GetTransactionsResponse) {
	if v, ok := m.GetResponseItems().(*ResponseItem_GetTransactionsResponse); ok {
		return v.GetTransactionsResponse
	}
	return x
}

// MarshalToWriter marshals ResponseItem to the provided writer.
func (m *ResponseItem) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	switch t := m.ResponseItems.(type) {
	case *ResponseItem_GetAccountStateResponse:
		if t.GetAccountStateResponse != nil {
			writer.WriteMessage(3, func() {
				t.GetAccountStateResponse.MarshalToWriter(writer)
			})
		}
	case *ResponseItem_GetAccountTransactionBySequenceNumberResponse:
		if t.GetAccountTransactionBySequenceNumberResponse != nil {
			writer.WriteMessage(4, func() {
				t.GetAccountTransactionBySequenceNumberResponse.MarshalToWriter(writer)
			})
		}
	case *ResponseItem_GetEventsByEventAccessPathResponse:
		if t.GetEventsByEventAccessPathResponse != nil {
			writer.WriteMessage(5, func() {
				t.GetEventsByEventAccessPathResponse.MarshalToWriter(writer)
			})
		}
	case *ResponseItem_GetTransactionsResponse:
		if t.GetTransactionsResponse != nil {
			writer.WriteMessage(6, func() {
				t.GetTransactionsResponse.MarshalToWriter(writer)
			})
		}
	}

	return
}

// Marshal marshals ResponseItem to a slice of bytes.
func (m *ResponseItem) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ResponseItem from the provided reader.
func (m *ResponseItem) UnmarshalFromReader(reader jspb.Reader) *ResponseItem {
	for reader.Next() {
		if m == nil {
			m = &ResponseItem{}
		}

		switch reader.GetFieldNumber() {
		case 3:
			reader.ReadMessage(func() {
				m.ResponseItems = &ResponseItem_GetAccountStateResponse{
					GetAccountStateResponse: new(GetAccountStateResponse).UnmarshalFromReader(reader),
				}
			})
		case 4:
			reader.ReadMessage(func() {
				m.ResponseItems = &ResponseItem_GetAccountTransactionBySequenceNumberResponse{
					GetAccountTransactionBySequenceNumberResponse: new(GetAccountTransactionBySequenceNumberResponse).UnmarshalFromReader(reader),
				}
			})
		case 5:
			reader.ReadMessage(func() {
				m.ResponseItems = &ResponseItem_GetEventsByEventAccessPathResponse{
					GetEventsByEventAccessPathResponse: new(GetEventsByEventAccessPathResponse).UnmarshalFromReader(reader),
				}
			})
		case 6:
			reader.ReadMessage(func() {
				m.ResponseItems = &ResponseItem_GetTransactionsResponse{
					GetTransactionsResponse: new(GetTransactionsResponse).UnmarshalFromReader(reader),
				}
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ResponseItem from a slice of bytes.
func (m *ResponseItem) Unmarshal(rawBytes []byte) (*ResponseItem, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Gets latest state for an account.
type GetAccountStateRequest struct {
	// Account for which we are fetching the state.
	Address []byte
}

// GetAddress gets the Address of the GetAccountStateRequest.
func (m *GetAccountStateRequest) GetAddress() (x []byte) {
	if m == nil {
		return x
	}
	return m.Address
}

// MarshalToWriter marshals GetAccountStateRequest to the provided writer.
func (m *GetAccountStateRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Address) > 0 {
		writer.WriteBytes(1, m.Address)
	}

	return
}

// Marshal marshals GetAccountStateRequest to a slice of bytes.
func (m *GetAccountStateRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GetAccountStateRequest from the provided reader.
func (m *GetAccountStateRequest) UnmarshalFromReader(reader jspb.Reader) *GetAccountStateRequest {
	for reader.Next() {
		if m == nil {
			m = &GetAccountStateRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Address = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GetAccountStateRequest from a slice of bytes.
func (m *GetAccountStateRequest) Unmarshal(rawBytes []byte) (*GetAccountStateRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// State information returned by a get account state query.
type GetAccountStateResponse struct {
	// Blob value representing the account state together with proof the client
	// can utilize to verify it.
	AccountStateWithProof *AccountStateWithProof
}

// GetAccountStateWithProof gets the AccountStateWithProof of the GetAccountStateResponse.
func (m *GetAccountStateResponse) GetAccountStateWithProof() (x *AccountStateWithProof) {
	if m == nil {
		return x
	}
	return m.AccountStateWithProof
}

// MarshalToWriter marshals GetAccountStateResponse to the provided writer.
func (m *GetAccountStateResponse) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.AccountStateWithProof != nil {
		writer.WriteMessage(1, func() {
			m.AccountStateWithProof.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals GetAccountStateResponse to a slice of bytes.
func (m *GetAccountStateResponse) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GetAccountStateResponse from the provided reader.
func (m *GetAccountStateResponse) UnmarshalFromReader(reader jspb.Reader) *GetAccountStateResponse {
	for reader.Next() {
		if m == nil {
			m = &GetAccountStateResponse{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.AccountStateWithProof = m.AccountStateWithProof.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GetAccountStateResponse from a slice of bytes.
func (m *GetAccountStateResponse) Unmarshal(rawBytes []byte) (*GetAccountStateResponse, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// -----------------------------------------------------------------------------
// ---------------- Get single transaction by account + sequence number
// -----------------------------------------------------------------------------
// Get transactions that altered an account - this includes both sent and
// received. A user of this should check that the data returned matches what
// they expect.  As an example, a potential attack vector would be something
// like the following: Alice is buying an apple from Bob. Alice's phone signs a
// transaction X with sequence number N that pays coins to Bob. Alice transmits
// this signature to Bob's payment terminal which then submits the transaction
// and checks its status to see if Alice can be given the apple. However, as Bob
// is doing this Alice constructs a second transaction X' also with sequence
// number N. Alice gets that transaction inserted in the blockchain. If Bob
// isn't thoughtful about how he uses this API he may assume that if he asks for
// the N'th transaction on Alice's account that when the API returns that this
// means the transaction has gone through. The point here is that one should be
// careful in reading too much into "transaction X is on the chain" and focus on
// the logs, which tell you what the transaction did.
//
// If a client submitted a transaction, they should also verify that the hash of
// the returned transaction matches what they submitted.  As an example, if a
// client has two wallets that share the same account, they may both submit a
// transaction at the same sequence number and only one will be committed.  A
// client should never assume that if they receive the response that this
// transaction was included that it means that this is definitely the
// transaction that was submitted.  They should check that the hash matches what
// they sent
type GetAccountTransactionBySequenceNumberRequest struct {
	// Account for which to query transactions
	Account        []byte
	SequenceNumber uint64
	// Set to true to fetch events for the transaction at this version
	FetchEvents bool
}

// GetAccount gets the Account of the GetAccountTransactionBySequenceNumberRequest.
func (m *GetAccountTransactionBySequenceNumberRequest) GetAccount() (x []byte) {
	if m == nil {
		return x
	}
	return m.Account
}

// GetSequenceNumber gets the SequenceNumber of the GetAccountTransactionBySequenceNumberRequest.
func (m *GetAccountTransactionBySequenceNumberRequest) GetSequenceNumber() (x uint64) {
	if m == nil {
		return x
	}
	return m.SequenceNumber
}

// GetFetchEvents gets the FetchEvents of the GetAccountTransactionBySequenceNumberRequest.
func (m *GetAccountTransactionBySequenceNumberRequest) GetFetchEvents() (x bool) {
	if m == nil {
		return x
	}
	return m.FetchEvents
}

// MarshalToWriter marshals GetAccountTransactionBySequenceNumberRequest to the provided writer.
func (m *GetAccountTransactionBySequenceNumberRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Account) > 0 {
		writer.WriteBytes(1, m.Account)
	}

	if m.SequenceNumber != 0 {
		writer.WriteUint64(2, m.SequenceNumber)
	}

	if m.FetchEvents {
		writer.WriteBool(3, m.FetchEvents)
	}

	return
}

// Marshal marshals GetAccountTransactionBySequenceNumberRequest to a slice of bytes.
func (m *GetAccountTransactionBySequenceNumberRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GetAccountTransactionBySequenceNumberRequest from the provided reader.
func (m *GetAccountTransactionBySequenceNumberRequest) UnmarshalFromReader(reader jspb.Reader) *GetAccountTransactionBySequenceNumberRequest {
	for reader.Next() {
		if m == nil {
			m = &GetAccountTransactionBySequenceNumberRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Account = reader.ReadBytes()
		case 2:
			m.SequenceNumber = reader.ReadUint64()
		case 3:
			m.FetchEvents = reader.ReadBool()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GetAccountTransactionBySequenceNumberRequest from a slice of bytes.
func (m *GetAccountTransactionBySequenceNumberRequest) Unmarshal(rawBytes []byte) (*GetAccountTransactionBySequenceNumberRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Transaction information for transactions requested by
// GetAccountTransactionsRequest
type GetAccountTransactionBySequenceNumberResponse struct {
	// When the transaction requested is committed, return the committed
	// transaction with proof.
	TransactionWithProof *TransactionWithProof
	// When the transaction requested is not committed, we give a proof that
	// shows the current sequence number is smaller than what would have been if
	// the transaction was committed.
	ProofOfCurrentSequenceNumber *AccountStateWithProof
}

// GetTransactionWithProof gets the TransactionWithProof of the GetAccountTransactionBySequenceNumberResponse.
func (m *GetAccountTransactionBySequenceNumberResponse) GetTransactionWithProof() (x *TransactionWithProof) {
	if m == nil {
		return x
	}
	return m.TransactionWithProof
}

// GetProofOfCurrentSequenceNumber gets the ProofOfCurrentSequenceNumber of the GetAccountTransactionBySequenceNumberResponse.
func (m *GetAccountTransactionBySequenceNumberResponse) GetProofOfCurrentSequenceNumber() (x *AccountStateWithProof) {
	if m == nil {
		return x
	}
	return m.ProofOfCurrentSequenceNumber
}

// MarshalToWriter marshals GetAccountTransactionBySequenceNumberResponse to the provided writer.
func (m *GetAccountTransactionBySequenceNumberResponse) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.TransactionWithProof != nil {
		writer.WriteMessage(2, func() {
			m.TransactionWithProof.MarshalToWriter(writer)
		})
	}

	if m.ProofOfCurrentSequenceNumber != nil {
		writer.WriteMessage(3, func() {
			m.ProofOfCurrentSequenceNumber.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals GetAccountTransactionBySequenceNumberResponse to a slice of bytes.
func (m *GetAccountTransactionBySequenceNumberResponse) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GetAccountTransactionBySequenceNumberResponse from the provided reader.
func (m *GetAccountTransactionBySequenceNumberResponse) UnmarshalFromReader(reader jspb.Reader) *GetAccountTransactionBySequenceNumberResponse {
	for reader.Next() {
		if m == nil {
			m = &GetAccountTransactionBySequenceNumberResponse{}
		}

		switch reader.GetFieldNumber() {
		case 2:
			reader.ReadMessage(func() {
				m.TransactionWithProof = m.TransactionWithProof.UnmarshalFromReader(reader)
			})
		case 3:
			reader.ReadMessage(func() {
				m.ProofOfCurrentSequenceNumber = m.ProofOfCurrentSequenceNumber.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GetAccountTransactionBySequenceNumberResponse from a slice of bytes.
func (m *GetAccountTransactionBySequenceNumberResponse) Unmarshal(rawBytes []byte) (*GetAccountTransactionBySequenceNumberResponse, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Get events that exist on an event access path.  In the current world,
// a user may specify events that were received, events that were sent, or any
// event that modifies their account
type GetEventsByEventAccessPathRequest struct {
	AccessPath *AccessPath
	// The sequence number of the event to start with for this query. Use a
	// sequence number of MAX_INT to represent the latest.
	StartEventSeqNum uint64
	// If ascending is true this query will return up to `limit` events that were
	// emitted after `start_event_seq_num`. Otherwise it will return up to `limit`
	// events before the offset. Both cases are inclusive.
	Ascending bool
	// Limit number of results
	Limit uint64
}

// GetAccessPath gets the AccessPath of the GetEventsByEventAccessPathRequest.
func (m *GetEventsByEventAccessPathRequest) GetAccessPath() (x *AccessPath) {
	if m == nil {
		return x
	}
	return m.AccessPath
}

// GetStartEventSeqNum gets the StartEventSeqNum of the GetEventsByEventAccessPathRequest.
func (m *GetEventsByEventAccessPathRequest) GetStartEventSeqNum() (x uint64) {
	if m == nil {
		return x
	}
	return m.StartEventSeqNum
}

// GetAscending gets the Ascending of the GetEventsByEventAccessPathRequest.
func (m *GetEventsByEventAccessPathRequest) GetAscending() (x bool) {
	if m == nil {
		return x
	}
	return m.Ascending
}

// GetLimit gets the Limit of the GetEventsByEventAccessPathRequest.
func (m *GetEventsByEventAccessPathRequest) GetLimit() (x uint64) {
	if m == nil {
		return x
	}
	return m.Limit
}

// MarshalToWriter marshals GetEventsByEventAccessPathRequest to the provided writer.
func (m *GetEventsByEventAccessPathRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.AccessPath != nil {
		writer.WriteMessage(1, func() {
			m.AccessPath.MarshalToWriter(writer)
		})
	}

	if m.StartEventSeqNum != 0 {
		writer.WriteUint64(2, m.StartEventSeqNum)
	}

	if m.Ascending {
		writer.WriteBool(3, m.Ascending)
	}

	if m.Limit != 0 {
		writer.WriteUint64(4, m.Limit)
	}

	return
}

// Marshal marshals GetEventsByEventAccessPathRequest to a slice of bytes.
func (m *GetEventsByEventAccessPathRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GetEventsByEventAccessPathRequest from the provided reader.
func (m *GetEventsByEventAccessPathRequest) UnmarshalFromReader(reader jspb.Reader) *GetEventsByEventAccessPathRequest {
	for reader.Next() {
		if m == nil {
			m = &GetEventsByEventAccessPathRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.AccessPath = m.AccessPath.UnmarshalFromReader(reader)
			})
		case 2:
			m.StartEventSeqNum = reader.ReadUint64()
		case 3:
			m.Ascending = reader.ReadBool()
		case 4:
			m.Limit = reader.ReadUint64()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GetEventsByEventAccessPathRequest from a slice of bytes.
func (m *GetEventsByEventAccessPathRequest) Unmarshal(rawBytes []byte) (*GetEventsByEventAccessPathRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type GetEventsByEventAccessPathResponse struct {
	// Returns an event and proof of each of the events in the request. The first
	// element of proofs will be the closest to `start_event_seq_num`.
	EventsWithProof []*EventWithProof
	// If the number of events returned is less than `limit` for an ascending
	// query or if start_event_seq_num > the latest seq_num for a descending
	// query,  returns the state of the account containing the given access path
	// in the latest state. This allows the client to verify that there are in
	// fact no extra events.
	//
	// The LedgerInfoWithSignatures which is on the main
	// UpdateToLatestLedgerResponse can be used to validate this.
	ProofOfLatestEvent *AccountStateWithProof
}

// GetEventsWithProof gets the EventsWithProof of the GetEventsByEventAccessPathResponse.
func (m *GetEventsByEventAccessPathResponse) GetEventsWithProof() (x []*EventWithProof) {
	if m == nil {
		return x
	}
	return m.EventsWithProof
}

// GetProofOfLatestEvent gets the ProofOfLatestEvent of the GetEventsByEventAccessPathResponse.
func (m *GetEventsByEventAccessPathResponse) GetProofOfLatestEvent() (x *AccountStateWithProof) {
	if m == nil {
		return x
	}
	return m.ProofOfLatestEvent
}

// MarshalToWriter marshals GetEventsByEventAccessPathResponse to the provided writer.
func (m *GetEventsByEventAccessPathResponse) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	for _, msg := range m.EventsWithProof {
		writer.WriteMessage(1, func() {
			msg.MarshalToWriter(writer)
		})
	}

	if m.ProofOfLatestEvent != nil {
		writer.WriteMessage(2, func() {
			m.ProofOfLatestEvent.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals GetEventsByEventAccessPathResponse to a slice of bytes.
func (m *GetEventsByEventAccessPathResponse) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GetEventsByEventAccessPathResponse from the provided reader.
func (m *GetEventsByEventAccessPathResponse) UnmarshalFromReader(reader jspb.Reader) *GetEventsByEventAccessPathResponse {
	for reader.Next() {
		if m == nil {
			m = &GetEventsByEventAccessPathResponse{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.EventsWithProof = append(m.EventsWithProof, new(EventWithProof).UnmarshalFromReader(reader))
			})
		case 2:
			reader.ReadMessage(func() {
				m.ProofOfLatestEvent = m.ProofOfLatestEvent.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GetEventsByEventAccessPathResponse from a slice of bytes.
func (m *GetEventsByEventAccessPathResponse) Unmarshal(rawBytes []byte) (*GetEventsByEventAccessPathResponse, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Get up to limit transactions starting from start_version.
type GetTransactionsRequest struct {
	// The version of the transaction to start with for this query.  Use a version
	// of MAX_INT to represent the latest.
	StartVersion uint64
	// Limit number of results
	Limit uint64
	// Set to true to fetch events for the transaction at each version
	FetchEvents bool
}

// GetStartVersion gets the StartVersion of the GetTransactionsRequest.
func (m *GetTransactionsRequest) GetStartVersion() (x uint64) {
	if m == nil {
		return x
	}
	return m.StartVersion
}

// GetLimit gets the Limit of the GetTransactionsRequest.
func (m *GetTransactionsRequest) GetLimit() (x uint64) {
	if m == nil {
		return x
	}
	return m.Limit
}

// GetFetchEvents gets the FetchEvents of the GetTransactionsRequest.
func (m *GetTransactionsRequest) GetFetchEvents() (x bool) {
	if m == nil {
		return x
	}
	return m.FetchEvents
}

// MarshalToWriter marshals GetTransactionsRequest to the provided writer.
func (m *GetTransactionsRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.StartVersion != 0 {
		writer.WriteUint64(1, m.StartVersion)
	}

	if m.Limit != 0 {
		writer.WriteUint64(2, m.Limit)
	}

	if m.FetchEvents {
		writer.WriteBool(3, m.FetchEvents)
	}

	return
}

// Marshal marshals GetTransactionsRequest to a slice of bytes.
func (m *GetTransactionsRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GetTransactionsRequest from the provided reader.
func (m *GetTransactionsRequest) UnmarshalFromReader(reader jspb.Reader) *GetTransactionsRequest {
	for reader.Next() {
		if m == nil {
			m = &GetTransactionsRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.StartVersion = reader.ReadUint64()
		case 2:
			m.Limit = reader.ReadUint64()
		case 3:
			m.FetchEvents = reader.ReadBool()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GetTransactionsRequest from a slice of bytes.
func (m *GetTransactionsRequest) Unmarshal(rawBytes []byte) (*GetTransactionsRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type GetTransactionsResponse struct {
	TxnListWithProof *TransactionListWithProof
}

// GetTxnListWithProof gets the TxnListWithProof of the GetTransactionsResponse.
func (m *GetTransactionsResponse) GetTxnListWithProof() (x *TransactionListWithProof) {
	if m == nil {
		return x
	}
	return m.TxnListWithProof
}

// MarshalToWriter marshals GetTransactionsResponse to the provided writer.
func (m *GetTransactionsResponse) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.TxnListWithProof != nil {
		writer.WriteMessage(1, func() {
			m.TxnListWithProof.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals GetTransactionsResponse to a slice of bytes.
func (m *GetTransactionsResponse) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GetTransactionsResponse from the provided reader.
func (m *GetTransactionsResponse) UnmarshalFromReader(reader jspb.Reader) *GetTransactionsResponse {
	for reader.Next() {
		if m == nil {
			m = &GetTransactionsResponse{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.TxnListWithProof = m.TxnListWithProof.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GetTransactionsResponse from a slice of bytes.
func (m *GetTransactionsResponse) Unmarshal(rawBytes []byte) (*GetTransactionsResponse, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}
